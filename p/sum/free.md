# 关于排队免单项目的随想记录
> 什么是排队免单，就是客户来店买东西，优惠金额统一进入一个免单池里，当池中金额足够支付订单列表第一那位的金额，就把免单池中的钱按该订单金额返到该订单用户的余额中，下次到店可以直接使用。

初步整理好逻辑后发现一个问题：如果按一个商品正常打九折的思路来推算，100元的商品，也就是会有近10元进入免单池，那么想免掉第一单，后面最少要10个人，每个人都支付100，才够。当然也可能会出现第二个人直接支付1000元的情况。但想免掉第二单就还需要相同多的金额进入免单池才行，后面排队的订单会越来越多，而免的频率并不会太快，最后就会失去排队免单带来的营销效果。
为此抛出第一个解决方法：

### 助力免单  

大致规则就是：订单的免单顺序变为根据助力分数来决定。那这样的话就需要一个排名系统，每个订单都会有一个名次，助力后名次会有变化。

简单点就是做一个排名的表，类似：
```sql
SELECT count(key) FROM orderList WHERE Score > YourScore
```
这样的话就能查出所有助力分数大于该订单的订单。看起来很简单就能完成这个功能，但如果订单量有一百万的时候，这样做那需要的时间就会很长，也就是订单越多问题越严重。后来想了想要不要加一层缓存，但仅靠缓存无法保证排名的一致性和可靠性。

那就换一种方式，只要能把查询排名的时间复杂度从O(n),降低到O(log n)就行。读一次库，剩下的就是排序。大概思路如下：

1. 初始化，建立一个哈希表，键为订单 ID，值为助力分数对象，ID-> 分数对象，时间为 O(n)。接下来，建立一个以（分数对象，ID）为大小的全部玩家数量 n 的二叉平衡树，其中每个节点额外记录左右子树的节点数量。时间为 O(nlog(n))。
2. 要找到某个订单的排名，我们只需要在哈希表中查找对应 ID 的分数对象的值 ，然后在二叉平衡树中根据其左节点以及父节点的左节点数量递归找到对应排名，时间为 O(log(n))。
3. 要找到某个区间内的排名，例如第 101 到 第 200 名，我们需要查找 100 次对应排名的玩家，时间为 O( k(log(n))，其中 k 为区间的大小。
4. 更新订单分数：更新哈希表，并且更新二叉平衡树的节点，时间为 O(log(n))。

至于并发问题，因为我用的是node写的后端，单线程无限循环，不断把队列里的请求拿出来进行合并，然后使用上面的算法执行，每次执行都是 1次 事务。
但有感觉单线程合并后的更新会是一个瓶颈。

还有一个方案那就是使用分布式缓存，比如redis。利用redis的zset数据类型来实现排行榜系统。这里需要注意的就是如何对redis里的数据进行备份。大概思路就是写个定时脚本，每周/月把数据保存的关系型数据库中。
### 支付  



本文思考时的参考来源：
- [Legend of the Criptids](https://zhuanlan.zhihu.com/p/108588438)
- [使用Redis实现实时排名](https://www.jianshu.com/p/2cbf358b933b)